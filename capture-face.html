<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Captura de Rosto</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      background: linear-gradient(to bottom, #1e3a8a, #3b82f6);
      font-family: 'Poppins', sans-serif;
      min-height: 100vh;
      margin: 0;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .capture-container {
      position: relative;
      z-index: 1000;
      background: transparent;
      max-width: 100vw;
      width: 100%;
      text-align: center;
    }
    .fullscreen-video {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: 1000;
      background: transparent;
      transform: scaleX(-1);
      display: block;
    }
    .confirmation-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1003;
    }
    .confirmation-modal img {
      max-width: 80%;
      max-height: 65%;
      aspect-ratio: 3 / 4;
      object-fit: cover;
      border-radius: 20px;
      border: 4px solid white;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
      cursor: zoom-in;
      transition: transform 0.3s, border-color 0.3s;
    }
    .confirmation-modal img:focus {
      border-color: #10b981;
      outline: none;
    }
    .confirmation-modal img.zoomed {
      transform: scale(1.5);
    }
    .confirmation-modal .buttons {
      position: absolute;
      bottom: 40px;
      display: flex;
      justify-content: center;
      gap: 2rem;
      width: 100%;
    }
    .modal-button {
      background: #3b82f6;
      border-radius: 14px;
      padding: 14px 40px;
      font-size: 18px;
      font-weight: 600;
      color: white;
      border: none;
      cursor: pointer;
      transition: background 0.2s, transform 0.2s;
    }
    .modal-button:hover {
      background: #2563eb;
      transform: translateY(-2px);
    }
    .modal-button.send {
      background: #10b981;
    }
    .modal-button.send:hover {
      background: #059669;
    }
    .face-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1001;
      pointer-events: none;
    }
    .face-oval {
      border: 8px solid white;
      border-radius: 50%;
      width: 40vw;
      height: 60vw;
      max-width: 320px;
      max-height: 480px;
      min-width: 220px;
      min-height: 330px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.6);
      background: transparent;
    }
    .face-oval.aligned {
      border-color: #10b981;
      animation: pulse 0.8s infinite;
    }
    @keyframes pulse {
      0% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 20px rgba(16, 185, 129, 0.6); }
      50% { transform: translate(-50%, -50%) scale(1.02); box-shadow: 0 0 30px rgba(16, 185, 129, 0.8); }
      100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 20px rgba(16, 185, 129, 0.6); }
    }
    .face-feedback {
      position: fixed;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 16px 32px;
      border-radius: 12px;
      font-size: 20px;
      font-weight: 600;
      z-index: 1002;
      max-width: 90%;
      text-align: center;
      animation: fadeIn 0.5s ease-in-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(-50%) translateY(20px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 16px 32px;
      border-radius: 12px;
      color: white;
      font-weight: 600;
      font-size: 16px;
      z-index: 1006;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: center;
      gap: 12px;
      role: alert;
      max-width: 90%;
    }
    .toast-error { background: #ef4444; }
    .toast-success { background: #10b981; }
    .toast-warning { background: #f59e0b; }
    .retry-button {
      background: #3b82f6;
      border-radius: 8px;
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: background 0.2s;
    }
    .retry-button:hover {
      background: #2563eb;
    }
    .model-loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 16px 24px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      z-index: 1004;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .model-loading::after {
      content: '';
      width: 16px;
      height: 16px;
      border: 3px solid white;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .debug-status {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px;
      border-radius: 6px;
      font-size: 12px;
      z-index: 1007;
    }
    .fallback-button {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #3b82f6;
      color: white;
      padding: 16px 24px;
      border-radius: 12px;
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
      z-index: 1003;
      display: none;
    }
    .fallback-button:hover {
      background: #2563eb;
    }
    @media (max-width: 640px) {
      .face-feedback {
        bottom: 100px;
        font-size: 16px;
        padding: 12px 24px;
      }
      .confirmation-modal img {
        max-width: 90vw;
        max-height: 55vh;
      }
      .confirmation-modal .buttons {
        bottom: 32px;
        flex-direction: column;
        gap: 1.5rem;
      }
      .modal-button {
        padding: 12px 32px;
        font-size: 16px;
      }
      .face-oval {
        width: 60vw;
        height: 90vw;
        max-width: 280px;
        max-height: 420px;
      }
      .toast {
        font-size: 14px;
        padding: 12px 24px;
        max-width: 85vw;
      }
    }
  </style>
</head>
<body role="application" aria-label="Aplica√ß√£o de captura de rosto">
  <div class="capture-container">
    <video id="face-video" autoplay playsinline muted aria-hidden="true"></video>
    <canvas id="face-canvas" class="hidden" aria-hidden="true"></canvas>
    <div id="face-overlay" class="face-overlay"></div>
    <div id="face-feedback" class="face-feedback">Iniciando detec√ß√£o...</div>
    <div id="confirmationModal" class="confirmation-modal hidden">
      <img id="confirmationImage" src="" alt="Foto capturada para verifica√ß√£o">
      <div class="buttons">
        <button id="repeatButton" class="modal-button" aria-label="Repetir captura">Repetir</button>
        <button id="sendButton" class="modal-button send" aria-label="Enviar foto">Enviar</button>
      </div>
    </div>
    <div id="toast" class="toast hidden" aria-live="polite"></div>
    <button id="fallbackButton" class="fallback-button">Iniciar C√¢mera</button>
  </div>
  <div id="modelLoading" class="model-loading hidden" aria-live="polite">Iniciando...</div>
  <div id="debugStatus" class="debug-status">Inicializando...</div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      if (window.location.protocol !== 'https:') {
        showToast('Este aplicativo requer HTTPS. Use um servidor seguro.', 'error', false);
        updateDebugStatus('Erro: HTTPS necess√°rio');
        return;
      }

      // Elementos DOM
      const faceVideo = document.getElementById('face-video');
      const faceCanvas = document.getElementById('face-canvas');
      const faceOverlay = document.getElementById('face-overlay');
      const faceFeedback = document.getElementById('face-feedback');
      const confirmationModal = document.getElementById('confirmationModal');
      const confirmationImage = document.getElementById('confirmationImage');
      const repeatButton = document.getElementById('repeatButton');
      const sendButton = document.getElementById('sendButton');
      const toast = document.getElementById('toast');
      const modelLoading = document.getElementById('modelLoading');
      const debugStatus = document.getElementById('debugStatus');
      const fallbackButton = document.getElementById('fallbackButton');

      // Vari√°veis de estado
      let stream = null;
      let isCapturing = false;
      let alignedFrames = 0;
      let isDetectionActive = false;
      let modelsLoaded = false;
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');

      // Inicializa√ß√£o
      confirmationModal.classList.add('hidden');
      confirmationImage.src = '';
      sessionStorage.removeItem('facePhoto');

      // Fun√ß√µes auxiliares
      function updateDebugStatus(message) {
        debugStatus.textContent = message;
        console.log(`Status: ${message}`);
      }

      function showToast(message, type = 'error', showRetry = true) {
        toast.innerHTML = message + (showRetry ? ' <button class="retry-button">Tentar novamente</button>' : '');
        toast.className = `toast toast-${type}`;
        toast.classList.remove('hidden');
        toast.style.zIndex = '1006';
        setTimeout(() => toast.classList.add('hidden'), type === 'error' ? 10000 : 5000);
        if (showRetry) {
          const retryButton = toast.querySelector('.retry-button');
          retryButton.removeEventListener('click', initialize);
          retryButton.addEventListener('click', initialize, { once: true });
        }
      }

      function stopStream() {
        if (stream) {
          stream.getTracks().forEach(track => track.stop());
          stream = null;
          faceVideo.srcObject = null;
          console.log('Stream fechado');
          updateDebugStatus('Stream fechado');
        }
      }

      // Carrega modelos de detec√ß√£o facial
      async function loadModels(attempt = 1, maxAttempts = 3) {
        const path = 'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights/';
        try {
          console.log(`Tentativa ${attempt} de carregar modelos de ${path}`);
          updateDebugStatus(`Carregando modelos (${attempt}/${maxAttempts})`);
          await Promise.race([
            Promise.all([
              faceapi.nets.tinyFaceDetector.loadFromUri(path),
              faceapi.nets.faceLandmark68Net.loadFromUri(path)
            ]),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout nos modelos')), 10000))
          ]);
          modelsLoaded = true;
          console.log('Modelos carregados');
          showToast('Modelos carregados!', 'success', false);
          updateDebugStatus('Modelos carregados');
          return true;
        } catch (error) {
          console.error(`Erro ao carregar modelos (tentativa ${attempt}):`, error);
          updateDebugStatus(`Erro nos modelos (${attempt}/${maxAttempts})`);
          if (attempt < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            return loadModels(attempt + 1, maxAttempts);
          }
          showToast('Modelos n√£o foram carregados corretamente.', 'warning', true);
          updateDebugStatus('Falha nos modelos');
          return false;
        }
      }

      // Configura o overlay com oval
      function setupOverlay() {
        console.log('Configurando overlay...');
        faceOverlay.innerHTML = '';
        const oval = document.createElement('div');
        oval.classList.add('face-oval');
        faceOverlay.appendChild(oval);
        const ovalRect = oval.getBoundingClientRect();
        console.log('Oval posicionado:', {
          screenWidth: window.innerWidth,
          screenHeight: window.innerHeight,
          ovalLeft: ovalRect.left,
          ovalTop: ovalRect.top,
          ovalWidth: ovalRect.width,
          ovalHeight: ovalRect.height
        });
        updateDebugStatus('Overlay configurado');
        // For√ßar visibilidade
        oval.style.border = '8px solid white';
        oval.style.display = 'block';
      }

      // Inicia o v√≠deo da c√¢mera
      async function startVideo() {
        try {
          updateDebugStatus('Iniciando v√≠deo...');
          stopStream();
          faceVideo.classList.add('fullscreen-video');
          faceVideo.style.display = 'block';
          faceVideo.style.zIndex = '1000';

          const constraints = {
            video: {
              facingMode: 'user',
              width: { ideal: 1280 },
              height: { ideal: 720 },
              frameRate: { ideal: 30 }
            }
          };

          console.log('Solicitando stream:', constraints);
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          if (!stream.active) throw new Error('Stream inv√°lido');
          faceVideo.srcObject = stream;
          console.log('Stream atribu√≠do:', stream);
          updateDebugStatus('Stream ativo');

          await new Promise((resolve, reject) => {
            faceVideo.onloadedmetadata = () => {
              console.log('Metadados:', {
                width: faceVideo.videoWidth,
                height: faceVideo.videoHeight,
                readyState: faceVideo.readyState
              });
              tempCanvas.width = faceVideo.videoWidth;
              tempCanvas.height = faceVideo.videoHeight;
              faceCanvas.width = faceVideo.videoWidth;
              faceCanvas.height = faceVideo.videoHeight;
              updateDebugStatus('Resolu√ß√£o definida');
              resolve();
            };
            faceVideo.onerror = () => {
              console.error('Erro no v√≠deo');
              updateDebugStatus('Erro no stream');
              reject(new Error('Erro no stream'));
            };
          });

          await faceVideo.play();
          console.log('V√≠deo iniciado');
          updateDebugStatus('V√≠deo iniciado');
          fallbackButton.classList.add('hidden');
          setupOverlay();
          isDetectionActive = true;
          detectFaces();
        } catch (error) {
          console.error('Erro ao iniciar v√≠deo:', error);
          let errorMessage = 'Erro ao iniciar o v√≠deo. Verifique a conex√£o.';
          if (error.name === 'NotAllowedError') {
            errorMessage = 'Permiss√µes n√£o autorizadas. Habilite a c√¢mera em Configura√ß√µes > Privacidade.';
          } else if (error.name === 'NotFoundError') {
            errorMessage = 'Nenhuma webcam encontrada. Verifique sua conex√£o.';
          } else if (error.name === 'NotReadableError') {
            errorMessage = 'Webcam em uso por outro aplicativo. Feche-o e tente novamente.';
          } else if (error.message.includes('Stream inv√°lido')) {
            errorMessage = 'Stream da webcam inv√°lido. Reinicie o dispositivo.';
          }
          showToast(errorMessage, 'error', true);
          updateDebugStatus('Erro no v√≠deo: ' + errorMessage);
          fallbackButton.classList.remove('hidden');
          stopStream();
        }
      }

      // Detecta rostos e verifica alinhamento no oval
      async function detectFaces() {
        console.log('Detectando rostos...');
        if (!isDetectionActive || faceVideo.paused || faceVideo.ended || isCapturing) {
          console.log('Detec√ß√£o pausada:', {
            isDetectionActive,
            isCapturing,
            paused: faceVideo.paused,
            ended: faceVideo.ended
          });
          faceFeedback.innerHTML = '‚è∏Ô∏è Detec√ß√£o pausada';
          faceFeedback.classList.remove('hidden');
          setTimeout(detectFaces, 100);
          return;
        }

        faceFeedback.classList.remove('hidden');
        if (!modelsLoaded) {
          faceFeedback.innerHTML = '‚ö†Ô∏è Detec√ß√£o facial indispon√≠vel';
          console.log('Modelos n√£o carregados');
          requestAnimationFrame(detectFaces);
          return;
        }

        try {
          tempCtx.save();
          tempCtx.scale(-1, 1);
          tempCtx.drawImage(faceVideo, -faceVideo.videoWidth, 0, faceVideo.videoWidth, faceVideo.videoHeight);
          tempCtx.restore();

          const options = new faceapi.TinyFaceDetectorOptions({ inputSize: 224, scoreThreshold: 0.5 });
          const detections = await faceapi.detectAllFaces(tempCanvas, options).withFaceLandmarks();

          const oval = faceOverlay.querySelector('.face-oval');
          if (!oval) {
            console.error('Oval n√£o encontrado no DOM');
            setupOverlay();
            faceFeedback.innerHTML = '‚ö†Ô∏è Overlay n√£o carregado';
            requestAnimationFrame(detectFaces);
            return;
          }

          const videoWidth = faceVideo.videoWidth;
          const videoHeight = faceVideo.videoHeight;
          const screenWidth = window.innerWidth;
          const screenHeight = window.innerHeight;
          const scaleX = screenWidth / videoWidth;
          const scaleY = screenHeight / videoHeight;
          const ovalRect = oval.getBoundingClientRect();

          // Coordenadas do oval na tela
          const ovalLeft = ovalRect.left;
          const ovalRight = ovalRect.right;
          const ovalTop = ovalRect.top;
          const ovalBottom = ovalRect.bottom;
          const ovalWidth = ovalRect.width;
          const ovalHeight = ovalRect.height;

          if (detections.length === 1) {
            const { box } = detections[0].detection;

            // Coordenadas da caixa do rosto na tela
            const faceLeft = screenWidth - (box.x + box.width) * scaleX;
            const faceRight = screenWidth - box.x * scaleX;
            const faceTop = box.y * scaleY;
            const faceBottom = (box.y + box.height) * scaleY;

            // Verifica se a caixa do rosto est√° dentro do oval
            const isInsideOval = (
              faceLeft >= ovalLeft + 0.05 * ovalWidth &&
              faceRight <= ovalRight - 0.05 * ovalWidth &&
              faceTop >= ovalTop + 0.05 * ovalHeight &&
              faceBottom <= ovalBottom - 0.05 * ovalHeight
            );

            // Verifica o tamanho do rosto
            const faceWidth = box.width * scaleX;
            const faceHeight = box.height * scaleY;
            const minWidth = 0.85 * ovalWidth;
            const maxWidth = 0.95 * ovalWidth;
            const isSizeCorrect = faceWidth >= minWidth && faceWidth <= maxWidth;

            console.log('Detec√ß√£o:', {
              face: { left: faceLeft, right: faceRight, top: faceTop, bottom: faceBottom },
              oval: { left: ovalLeft, right: ovalRight, top: ovalTop, bottom: ovalBottom },
              isInsideOval,
              faceWidth,
              minWidth,
              maxWidth,
              isSizeCorrect
            });

            if (isInsideOval && isSizeCorrect) {
              alignedFrames++;
              if (alignedFrames >= 3 && !isCapturing) {
                oval.classList.add('aligned');
                const sharpness = calculateSharpness();
                if (sharpness > 0.05) {
                  isCapturing = true;
                  faceFeedback.innerHTML = 'üì∏ Capturando...';
                  console.log('Captura iniciada');
                  updateDebugStatus('Capturando');
                  captureFace();
                  return;
                } else {
                  faceFeedback.innerHTML = 'üí° Melhore a ilumina√ß√£o';
                  alignedFrames = 0;
                }
              } else {
                faceFeedback.innerHTML = '‚úÖ Alinhado! Aguarde...';
                updateDebugStatus('Rosto alinhado');
              }
            } else {
              alignedFrames = 0;
              oval.classList.remove('aligned');
              if (!isInsideOval) {
                faceFeedback.innerHTML = '‚Üî Ajuste o rosto ao oval';
              } else if (faceWidth < minWidth) {
                faceFeedback.innerHTML = 'üîç Aproxime o rosto';
              } else {
                faceFeedback.innerHTML = 'üîç Afastar o rosto';
              }
              updateDebugStatus('Rosto desalinhado');
            }
          } else {
            alignedFrames = 0;
            oval.classList.remove('aligned');
            faceFeedback.innerHTML = detections.length === 0 ? 'üò∂ Nenhum rosto detectado' : '‚ö†Ô∏è Apenas um rosto';
            updateDebugStatus('Nenhum ou m√∫ltiplos rostos');
          }
        } catch (error) {
          console.error('Erro na detec√ß√£o:', error);
          showToast('Erro na detec√ß√£o facial.', 'error', true);
          updateDebugStatus('Erro na detec√ß√£o');
          faceFeedback.innerHTML = '‚ö†Ô∏è Erro na detec√ß√£o';
        }
        faceFeedback.classList.remove('hidden');
        requestAnimationFrame(detectFaces);
      }

      // Calcula nitidez da imagem
      function calculateSharpness() {
        try {
          const regionSize = 80;
          const centerX = faceVideo.videoWidth / 2 - regionSize / 2;
          const centerY = faceVideo.videoHeight / 2 - regionSize / 2;
          const imageData = tempCtx.getImageData(centerX, centerY, regionSize, regionSize);
          const data = imageData.data;
          let laplacianSum = 0;
          let count = 0;

          for (let i = 1; i < regionSize - 1; i++) {
            for (let j = 1; j < regionSize - 1; j++) {
              const idx = (i * regionSize + j) * 4;
              const gray = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
              const laplacian =
                -4 * gray +
                (data[((i - 1) * regionSize + j) * 4] * 0.299 + data[((i - 1) * regionSize + j) * 4 + 1] * 0.587 + data[((i - 1) * regionSize + j) * 4 + 2] * 0.114) +
                (data[((i + 1) * regionSize + j) * 4] * 0.299 + data[((i + 1) * regionSize + j) * 4 + 1] * 0.587 + data[((i + 1) * regionSize + j) * 4 + 2] * 0.114) +
                (data[(i * regionSize + (j - 1)) * 4] * 0.299 + data[(i * regionSize + (j - 1)) * 4 + 1] * 0.587 + data[(i * regionSize + (j - 1)) * 4 + 2] * 0.114) +
                (data[(i * regionSize + (j + 1)) * 4] * 0.299 + data[(i * regionSize + (j + 1)) * 4 + 1] * 0.587 + data[(i * regionSize + (j + 1)) * 4 + 2] * 0.114);
              laplacianSum += laplacian * laplacian;
              count++;
            }
          }
          const sharpness = count ? laplacianSum / count : 0;
          const normalizedSharpness = sharpness / 1000;
          console.log('Nitidez:', normalizedSharpness);
          return normalizedSharpness;
        } catch (error) {
          console.error('Erro ao calcular nitidez:', error);
          showToast('Erro na an√°lise de qualidade.', 'error', true);
          updateDebugStatus('Erro na nitidez');
          return 0;
        }
      }

      // Captura a foto
      function captureFace() {
        if (faceVideo.readyState < 2) {
          showToast('V√≠deo n√£o est√° pronto.', 'error', true);
          console.error('V√≠deo n√£o est√° pronto:', {
            readyState: faceVideo.readyState,
            width: faceVideo.videoWidth,
            height: faceVideo.videoHeight
          });
          isCapturing = false;
          isDetectionActive = true;
          detectFaces();
          updateDebugStatus('V√≠deo n√£o captur√°vel');
          return;
        }

        faceCanvas.width = faceVideo.videoWidth;
        faceCanvas.height = faceVideo.videoHeight;
        const ctx = faceCanvas.getContext('2d');
        ctx.save();
        ctx.scale(-1, 1);
        ctx.drawImage(faceVideo, -faceVideo.videoWidth, 0, faceVideo.videoWidth, faceVideo.videoHeight);
        ctx.restore();

        try {
          const targetWidth = Math.min(faceVideo.videoWidth, faceVideo.videoHeight * 3 / 4);
          const targetHeight = targetWidth * 4 / 3;
          const offsetX = (faceVideo.videoWidth - targetWidth) / 2;
          const offsetY = (faceVideo.videoHeight - targetHeight) / 2;

          const cropCanvas = document.createElement('canvas');
          cropCanvas.width = targetWidth;
          cropCanvas.height = targetHeight;
          const cropCtx = cropCanvas.getContext('2d');
          cropCtx.drawImage(
            faceCanvas,
            offsetX, offsetY, targetWidth, targetHeight,
            0, 0, targetWidth, targetHeight
          );

          const imageData = cropCanvas.toDataURL('image/jpeg', 0.98);
          if (!imageData || imageData === 'data:,') {
            throw new Error('Imagem inv√°lida');
          }
          confirmationImage.src = imageData;
          confirmationModal.classList.remove('hidden');
          console.log('Foto capturada');
          updateDebugStatus('Foto capturada');
        } catch (error) {
          console.error('Erro ao capturar:', error);
          showToast('Erro ao capturar foto.', 'error', true);
          isCapturing = false;
          isDetectionActive = true;
          detectFaces();
          updateDebugStatus('Erro na captura');
          return;
        }

        stopStream();
        faceFeedback.classList.add('hidden');
        faceOverlay.innerHTML = '';
      }

      // Event listeners
      repeatButton.addEventListener('click', () => {
        confirmationModal.classList.add('hidden');
        confirmationImage.src = '';
        console.log('Repetindo captura');
        updateDebugStatus('Repetindo');
        initialize();
      });

      sendButton.addEventListener('click', () => {
        sessionStorage.setItem('facePhoto', confirmationImage.src);
        confirmationModal.classList.add('hidden');
        console.log('Foto enviada');
        updateDebugStatus('Foto enviada');
        const urlParams = new URLSearchParams(window.location.search);
        const returnPage = urlParams.get('return') || 'index.html';
        window.location.href = returnPage;
      });

      confirmationImage.addEventListener('click', () => {
        confirmationImage.classList.toggle('zoomed');
        console.log('Zoom da imagem');
        updateDebugStatus('Zoom');
      });

      fallbackButton.addEventListener('click', () => {
        fallbackButton.classList.add('hidden');
        initialize();
        console.log('Fallback clicado');
        updateDebugStatus('Fallback acionado');
      });

      document.addEventListener('click', () => {
        if (faceVideo.paused && stream) {
          faceVideo.play().catch(err => {
            console.error('Erro ao play ap√≥s clique:', err);
            updateDebugStatus('Erro ao play');
            fallbackButton.classList.remove('hidden');
          });
        }
      }, { once: true });

      // Inicializa a aplica√ß√£o
      async function initialize() {
        modelLoading.classList.remove('hidden');
        updateDebugStatus('Inicializando...');
        try {
          await startVideo();
          await loadModels();
        } catch (error) {
          console.error('Erro na inicializa√ß√£o:', error);
          showToast('Erro ao iniciar. Tente novamente.', 'error', true);
          updateDebugStatus('Erro na inicializa√ß√£o');
        } finally {
          modelLoading.classList.add('hidden');
        }
      }

      initialize();
    });
  </script>
</body>
</html>
