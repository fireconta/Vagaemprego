<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Captura de Imagem</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <style>
    body {
      background: linear-gradient(to bottom, #0f172a, #1e3a8a);
      font-family: 'Inter', 'Roboto', sans-serif;
      margin: 0;
      padding: 0;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .capture-container {
      position: relative;
      z-index: 1000;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .fullscreen-video {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: 999;
      transform: scaleX(-1);
      display: block;
      visibility: visible;
    }
    .confirmation-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(8px);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1003;
      padding: 12px;
    }
    .confirmation-modal img {
      max-width: 90%;
      max-height: 70%;
      aspect-ratio: 3/4;
      object-fit: cover;
      border-radius: 12px;
      border: 2px solid #ffffff;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
      cursor: zoom-in;
      transition: transform 0.3s ease;
    }
    .confirmation-modal img.zoomed {
      transform: scale(1.3);
    }
    .confirmation-modal .buttons {
      display: flex;
      justify-content: center;
      gap: 12px;
      width: 100%;
      max-width: 600px;
      margin-top: 16px;
    }
    .modal-button {
      background: #3b82f6;
      border-radius: 8px;
      padding: 12px 24px;
      font-size: 16px;
      font-weight: 600;
      color: white;
      border: none;
      cursor: pointer;
      transition: background 0.2s, transform 0.2s;
      width: 160px;
    }
    .modal-button:hover {
      background: #2563eb;
      transform: translateY(-2px);
    }
    .modal-button.send {
      background: #10b981;
    }
    .modal-button.send:hover {
      background: #059669;
    }
    .face-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      height: 600px;
      z-index: 1001;
    }
    .face-oval {
      border: 4px solid #ffffff;
      border-radius: 50%;
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
      background: transparent;
      transition: border-color 0.3s ease;
    }
    .face-oval.no-face {
      border-color: #ef4444;
    }
    .face-oval.misaligned {
      border-color: #f59e0b;
    }
    .face-oval.aligned {
      border-color: #10b981;
      animation: pulse 1s infinite ease-in-out;
    }
    @keyframes pulse {
      0% { transform: scale(1); box-shadow: 0 0 10px rgba(16, 185, 129, 0.3); }
      50% { transform: scale(1.015); box-shadow: 0 0 20px rgba(16, 185, 129, 0.5); }
      to { transform: scale(1); box-shadow: 0 0 10px rgba(16, 185, 129, 0.3); }
    }
    .face-feedback {
      position: fixed;
      bottom: 5vh;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 18px;
      font-weight: 600;
      z-index: 1002;
      max-width: 80vw;
      text-align: center;
      animation: fadeIn 0.4s ease-in-out;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }
    .countdown {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      color: white;
      font-size: 80px;
      font-weight: 700;
      padding: 20px 40px;
      border-radius: 8px;
      z-index: 1003;
      display: none;
      animation: countdownFade 1s ease-in-out;
    }
    @keyframes countdownFade {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
      50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(-50%) translateY(15px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      font-size: 14px;
      z-index: 1006;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: center;
      gap: 8px;
      max-width: 90%;
    }
    .toast-error { background: #ef4444; }
    .toast-success { background: #10b981; }
    .toast-warning { background: #f59e0b; }
    .retry-button {
      background: #3b82f6;
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: background 0.2s;
    }
    .retry-button:hover {
      background: #2563eb;
    }
    .model-loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      z-index: 1004;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .model-loading::after {
      content: '';
      width: 14px;
      height: 14px;
      border: 2px solid white;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .debug-status {
      position: fixed;
      top: 8px;
      left: 8px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 11px;
      z-index: 1007;
    }
    .fallback-button,
    .start-button {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #3b82f6;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      z-index: 1003;
      display: none;
    }
    .fallback-button:hover,
    .start-button:hover {
      background: #2563eb;
    }
    @media (max-width: 640px) {
      .face-feedback {
        bottom: 8vh;
        font-size: 14px;
        padding: 10px 20px;
      }
      .confirmation-modal img {
        max-width: 90%;
        max-height: 50%;
      }
      .confirmation-modal .buttons {
        flex-direction: column;
        gap: 12px;
        margin-top: 12px;
      }
      .modal-button {
        width: 80%;
        padding: 12px;
        font-size: 15px;
      }
      .face-overlay {
        width: 340px;
        height: 510px;
      }
      .countdown {
        font-size: 60px;
        padding: 15px 30px;
      }
      .toast {
        font-size: 13px;
        padding: 10px 20px;
        max-width: 85%;
      }
    }
  </style>
</head>
<body role="application" aria-label="Aplica√ß√£o de captura de imagem">
  <div class="capture-container">
    <video id="face-video" autoplay playsinline muted aria-hidden="true"></video>
    <canvas id="face-canvas" class="hidden" aria-hidden="true"></canvas>
    <div id="face-overlay" class="face-overlay" aria-label="Overlay para alinhamento do rosto"></div>
    <div id="face-feedback" class="face-feedback hidden" aria-live="polite">üòä Centralize o rosto</div>
    <div id="countdown" class="countdown" aria-live="polite"></div>
    <div id="confirmationModal" class="confirmation-modal hidden">
      <img id="confirmationImage" src="" alt="Foto capturada para verifica√ß√£o" tabindex="0">
      <div class="buttons">
        <button id="repeatButton" class="modal-button" aria-label="Repetir a captura da foto">Repetir</button>
        <button id="sendButton" class="modal-button send" aria-label="Enviar a foto capturada">Enviar</button>
      </div>
    </div>
    <div id="toast" class="toast hidden" aria-live="polite"></div>
    <button id="startButton" class="start-button" aria-label="Iniciar captura com a c√¢mera">Iniciar C√¢mera</button>
    <button id="fallbackButton" class="fallback-button" aria-label="Tentar novamente a inicializa√ß√£o">Tentar Novamente</button>
  </div>
  <div id="modelLoading" class="model-loading hidden" aria-live="polite">Carregando...</div>
  <div id="debugStatus" class="debug-status">Inicializando...</div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Elementos DOM
      const faceVideo = document.getElementById('face-video');
      const faceCanvas = document.getElementById('face-canvas');
      const faceOverlay = document.getElementById('face-overlay');
      const faceFeedback = document.getElementById('face-feedback');
      const countdown = document.getElementById('countdown');
      const confirmationModal = document.getElementById('confirmationModal');
      const confirmationImage = document.getElementById('confirmationImage');
      const repeatButton = document.getElementById('repeatButton');
      const sendButton = document.getElementById('sendButton');
      const toast = document.getElementById('toast');
      const modelLoading = document.getElementById('modelLoading');
      const debugStatus = document.getElementById('debugStatus');
      const startButton = document.getElementById('startButton');
      const fallbackButton = document.getElementById('fallbackButton');

      // For√ßar HTTPS no GitHub Pages
      if (window.location.hostname.includes('github.io') && window.location.protocol !== 'https:') {
        window.location.protocol = 'https:';
        return;
      }

      // Verifica HTTPS
      if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
        showToast('Este aplicativo requer HTTPS. Use um servidor seguro.', 'error', false);
        updateDebugStatus('Erro: HTTPS necess√°rio');
        startButton.style.display = 'none';
        return;
      }

      // Vari√°veis de estado
      let stream = null;
      let isCapturing = false;
      let alignedFrames = 0;
      let isDetectionActive = false;
      let modelsLoaded = false;
      let isCountingDown = false;
      let failedDetections = 0;
      let lastDetectionTime = 0;
      let lastDetections = null;
      const detectionInterval = 50;
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      let cachedDimensions = null;

      // Inicializa√ß√£o
      confirmationModal.classList.add('hidden');
      confirmationImage.src = '';
      sessionStorage.removeItem('facePhoto');
      faceVideo.style.display = 'none';
      startButton.style.display = 'none';

      // Fun√ß√µes auxiliares
      function updateDebugStatus(message) {
        debugStatus.textContent = message;
        console.log(`Status: ${message}`);
      }

      function showToast(message, type = 'error', showRetry = true) {
        if (!toast) return;
        toast.innerHTML = message + (showRetry ? ' <button class="retry-button">Tentar novamente</button>' : '');
        toast.className = `toast toast-${type}`;
        toast.classList.remove('hidden');
        setTimeout(() => toast.classList.add('hidden'), type === 'error' ? 12000 : 4000);
        if (showRetry) {
          const retryButton = toast.querySelector('.retry-button');
          retryButton.removeEventListener('click', initialize);
          retryButton.addEventListener('click', initialize, { once: true });
        }
      }

      function stopStream() {
        if (stream) {
          stream.getTracks().forEach(track => {
            track.stop();
            console.log('Track parado:', track.id);
          });
          stream = null;
          faceVideo.srcObject = null;
          faceVideo.pause();
          faceVideo.style.display = 'none';
          faceVideo.style.visibility = 'hidden';
          updateDebugStatus('Stream fechado');
        }
      }

      // Verifica dimens√µes do v√≠deo
      function getVideoDimensions() {
        if (faceVideo.readyState >= 2 && faceVideo.videoWidth && faceVideo.videoHeight) {
          return { width: faceVideo.videoWidth, height: faceVideo.videoHeight };
        }
        console.warn('Dimens√µes do v√≠deo n√£o dispon√≠veis, usando fallback');
        return { width: 640, height: 480 };
      }

      // Carrega modelos
      async function loadModels(attempt = 1, maxAttempts = 3) {
        const path = 'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights/';
        const fallbackPath = 'https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/weights/';
        try {
          updateDebugStatus(`Carregando modelos (${attempt}/${maxAttempts})`);
          console.log('Carregando modelos de:', path);
          await Promise.race([
            Promise.all([
              faceapi.nets.ssdMobilenetv1.loadFromUri(path),
              faceapi.nets.faceLandmark68Net.loadFromUri(path)
            ]),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout nos modelos')), 20000))
          ]);
          modelsLoaded = true;
          showToast('Modelos carregados!', 'success', false);
          updateDebugStatus('Modelos carregados');
          return true;
        } catch (error) {
          console.error(`Erro ao carregar modelos (tentativa ${attempt}):`, error);
          updateDebugStatus(`Erro nos modelos: ${error.message}`);
          if (attempt < maxAttempts) {
            if (error.message.includes('Failed to fetch') || error.message.includes('network')) {
              console.warn('Falha no GitHub, tentando CDN');
              try {
                updateDebugStatus(`Tentando fallback CDN (${attempt}/${maxAttempts})`);
                await Promise.all([
                  faceapi.nets.ssdMobilenetv1.loadFromUri(fallbackPath),
                  faceapi.nets.faceLandmark68Net.loadFromUri(fallbackPath)
                ]);
                modelsLoaded = true;
                showToast('Modelos carregados via CDN!', 'success', false);
                updateDebugStatus('Modelos carregados via CDN');
                return true;
              } catch (fallbackError) {
                console.error('Erro no fallback CDN:', fallbackError);
              }
            }
            await new Promise(resolve => setTimeout(resolve, 2000));
            return loadModels(attempt + 1, maxAttempts);
          }
          showToast('Falha ao carregar detec√ß√£o facial.', 'error', true);
          return false;
        }
      }

      // Configura overlay
      function setupOverlay() {
        faceOverlay.innerHTML = '';
        const oval = document.createElement('div');
        oval.classList.add('face-oval');
        oval.setAttribute('aria-label', 'Oval para alinhamento do rosto');
        faceOverlay.appendChild(oval);
        updateCachedDimensions();
        updateDebugStatus('Oval configurado');
      }

      // Cache de dimens√µes
      function updateCachedDimensions() {
        const oval = faceOverlay.querySelector('.face-oval');
        if (!oval) return;
        const ovalRect = oval.getBoundingClientRect();
        const { width: videoWidth, height: videoHeight } = getVideoDimensions();
        cachedDimensions = {
          videoWidth,
          videoHeight,
          screenWidth: window.innerWidth,
          screenHeight: window.innerHeight,
          ovalLeft: ovalRect.left,
          ovalRight: ovalRect.right,
          ovalTop: ovalRect.top,
          ovalBottom: ovalRect.bottom,
          ovalWidth: ovalRect.width,
          ovalHeight: ovalRect.height
        };
        console.log('Dimens√µes cacheadas:', cachedDimensions);
      }

      // Verifica permiss√µes
      async function checkCameraPermission() {
        try {
          const permissionStatus = await navigator.permissions.query({ name: 'camera' });
          console.log('Permiss√£o:', permissionStatus.state);
          if (permissionStatus.state === 'denied') {
            return { granted: false, message: 'Permiss√£o para c√¢mera negada. Habilite nas configura√ß√µes.' };
          }
          return { granted: true };
        } catch (error) {
          console.error('Erro ao verificar permiss√£o:', error);
          return { granted: false, message: 'Erro ao verificar permiss√£o.' };
        }
      }

      // Tenta reproduzir v√≠deo
      async function tryPlayVideo(attempt = 1, maxAttempts = 7) {
        try {
          await faceVideo.play();
          console.log('V√≠deo iniciado, readyState:', faceVideo.readyState, 'Dimens√µes:', getVideoDimensions());
          updateDebugStatus('V√≠deo iniciado');
          return true;
        } catch (error) {
          console.error(`Erro ao reproduzir v√≠deo (tentativa ${attempt}):`, error);
          updateDebugStatus(`Erro ao reproduzir: ${error.message}`);
          if (attempt < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            return tryPlayVideo(attempt + 1, maxAttempts);
          }
          return false;
        }
      }

      // Inicia v√≠deo
      async function startVideo(attempt = 1, maxAttempts = 5) {
        try {
          updateDebugStatus('Iniciando v√≠deo...');
          console.log(`Tentativa ${attempt} de iniciar v√≠deo`);
          stopStream();
          faceVideo.classList.add('fullscreen-video');
          faceVideo.style.display = 'block';
          faceVideo.style.visibility = 'visible';

          const permission = await checkCameraPermission();
          if (!permission.granted) {
            throw new Error(permission.message);
          }

          const constraints = {
            video: {
              facingMode: 'user',
              width: { ideal: 640 },
              height: { ideal: 480 },
              frameRate: { ideal: 30 }
            }
          };

          stream = await navigator.mediaDevices.getUserMedia(constraints);
          console.log('Stream ativo:', stream.id);
          faceVideo.srcObject = stream;
          updateDebugStatus('Stream ativo');

          await new Promise((resolve, reject) => {
            faceVideo.onloadedmetadata = () => {
              const dims = getVideoDimensions();
              console.log('Metadados:', {
                readyState: faceVideo.readyState,
                width: dims.width,
                height: dims.height
              });
              if (!dims.width || !dims.height) {
                reject(new Error('Dimens√µes do v√≠deo n√£o dispon√≠veis'));
                return;
              }
              tempCanvas.width = dims.width;
              tempCanvas.height = dims.height;
              faceCanvas.width = dims.width;
              faceCanvas.height = dims.height;
              updateDebugStatus('Resolu√ß√£o definida');
              resolve();
            };
            faceVideo.onerror = () => {
              reject(new Error('Erro no stream'));
            };
            setTimeout(() => reject(new Error('Timeout de metadados')), 15000);
          });

          const played = await tryPlayVideo();
          if (!played) {
            throw new Error('N√£o foi poss√≠vel reproduzir o v√≠deo.');
          }

          setupOverlay();
          isDetectionActive = true;
          faceFeedback.classList.remove('hidden');
          detectFaces();
          return true;
        } catch (error) {
          console.error(`Erro ao iniciar v√≠deo (tentativa ${attempt}):`, error);
          let errorMessage = 'N√£o foi poss√≠vel acessar a c√¢mera.';
          if (error.name === 'NotAllowedError' || error.message.includes('Permiss√£o')) {
            errorMessage = 'Permiss√£o para c√¢mera negada. Habilite nas configura√ß√µes.';
          } else if (error.name === 'NotFoundError') {
            errorMessage = 'Nenhuma c√¢mera encontrada.';
          } else if (error.name === 'NotReadableError') {
            errorMessage = 'C√¢mera em uso por outro aplicativo.';
            if (attempt < maxAttempts - 1) {
              console.warn('C√¢mera ocupada, tentando novamente ap√≥s 3s');
              await new Promise(resolve => setTimeout(resolve, 3000));
              return startVideo(attempt + 1, maxAttempts);
            }
          } else if (error.name === 'OverconstrainedError' || error.message.includes('Dimens√µes')) {
            errorMessage = 'Resolu√ß√£o n√£o suportada.';
          } else {
            errorMessage = `Erro: ${error.message}`;
          }
          showToast(errorMessage, 'error', true);
          faceFeedback.innerHTML = 'üì∑ Verifique a c√¢mera';
          updateDebugStatus(`Erro no v√≠deo: ${errorMessage}`);
          if (attempt < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 2000));
            return startVideo(attempt + 1, maxAttempts);
          }
          startButton.style.display = 'block';
          stopStream();
          return false;
        }
      }

      // Calcula √¢ngulo do rosto
      function calculateFaceAngle(landmarks) {
        const leftEye = landmarks.positions[36];
        const rightEye = landmarks.positions[45];
        const deltaY = rightEye.y - leftEye.y;
        const deltaX = rightEye.x - leftEye.x;
        const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
        return Math.abs(angle);
      }

      // Contagem regressiva
      async function startCountdown() {
        console.log('Iniciando contagem regressiva');
        if (isCountingDown || isCapturing) {
          console.warn('Contagem ou captura j√° em andamento');
          return;
        }
        const dims = getVideoDimensions();
        if (faceVideo.readyState < 2 || !dims.width || !dims.height) {
          showToast('C√¢mera n√£o est√° pronta.', 'error', true);
          updateDebugStatus('Erro: V√≠deo n√£o pronto para contagem');
          isDetectionActive = true;
          faceFeedback.innerHTML = 'üì∑ Verifique a c√¢mera';
          return;
        }

        isCountingDown = true;
        isDetectionActive = false;
        faceFeedback.innerHTML = 'üòä Mantenha o rosto no centro';
        countdown.style.display = 'block';

        try {
          for (let i = 3; i >= 1; i--) {
            countdown.textContent = i;
            await new Promise(resolve => setTimeout(resolve, 1000));

            if (faceVideo.readyState < 2) {
              throw new Error('V√≠deo n√£o est√° pronto durante a contagem');
            }

            const width = dims.width;
            const height = dims.height;
            tempCanvas.width = width;
            tempCanvas.height = height;
            tempCtx.save();
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(faceVideo, -width, 0, width, height);
            tempCtx.restore();

            const sharpness = calculateSharpness();
            const oval = faceOverlay.querySelector('.face-oval');
            if (sharpness <= 0.05) {
              if (failedDetections < 5) {
                failedDetections++;
                countdown.style.display = 'none';
                isCountingDown = false;
                isDetectionActive = true;
                alignedFrames = 0;
                faceFeedback.innerHTML = 'üí° V√° para um local mais iluminado';
                if (oval) oval.classList.remove('aligned', 'misaligned').add('no-face');
                console.log('Ilumina√ß√£o baixa, reiniciando detec√ß√£o');
                return;
              } else {
                showToast('Ilumina√ß√£o baixa. Capturando manualmente.', 'warning', false);
              }
            }

            const isMobile = window.innerWidth <= 640;
            const options = new faceapi.SsdMobilenetv1Options({ minConfidence: 0.3 });
            let detections = lastDetections;
            if (!detections || performance.now() - lastDetectionTime > 100) {
              try {
                detections = await faceapi.detectAllFaces(tempCanvas, options).withFaceLandmarks();
                lastDetections = detections;
              } catch (error) {
                console.error('Erro na detec√ß√£o durante contagem:', error);
                countdown.style.display = 'none';
                isCountingDown = false;
                isDetectionActive = true;
                alignedFrames = 0;
                faceFeedback.innerHTML = '‚ö†Ô∏è Erro na detec√ß√£o';
                if (oval) oval.classList.remove('aligned', 'misaligned').add('no-face');
                updateDebugStatus('Erro na detec√ß√£o durante contagem');
                return;
              }
            }

            if (!oval || detections.length !== 1) {
              countdown.style.display = 'none';
              isCountingDown = false;
              isDetectionActive = true;
              alignedFrames = 0;
              faceFeedback.innerHTML = detections.length === 0 ? 'üò∂ Sem rosto detectado' : '‚ö†Ô∏è Apenas um rosto';
              if (oval) oval.classList.remove('aligned', 'misaligned').add('no-face');
              console.log('Detec√ß√£o inv√°lida:', detections.length);
              return;
            }

            const { box, landmarks } = detections[0];
            const angle = calculateFaceAngle(landmarks);
            if (angle > 15) {
              countdown.style.display = 'none';
              isCountingDown = false;
              isDetectionActive = true;
              alignedFrames = 0;
              faceFeedback.innerHTML = 'üôÇ Alinhe o rosto';
              if (oval) oval.classList.remove('aligned', 'no-face').add('misaligned');
              console.log('Rosto inclinado, √¢ngulo:', angle);
              return;
            }

            updateCachedDimensions();
            const { videoWidth, screenWidth, screenHeight, ovalLeft, ovalRight, ovalTop, ovalBottom, ovalWidth, ovalHeight } = cachedDimensions;
            const scaleX = screenWidth / videoWidth;
            const scaleY = screenHeight / videoHeight;

            const faceLeft = screenWidth - (box.x + box.width) * scaleX;
            const faceRight = screenWidth - box.x * scaleX;
            const faceTop = box.y * scaleY;
            const faceBottom = (box.y + box.height) * scaleY;

            const isInsideOval = (
              faceLeft >= ovalLeft + 0.05 * ovalWidth &&
              faceRight <= ovalRight - 0.05 * ovalWidth &&
              faceTop >= ovalTop + 0.05 * ovalHeight &&
              faceBottom <= ovalBottom - 0.05 * ovalHeight
            );

            const faceWidth = box.width * scaleX;
            const minWidth = 0.85 * ovalWidth;
            const maxWidth = 1.1 * ovalWidth;
            const isSizeCorrect = faceWidth >= minWidth && faceWidth <= maxWidth;

            if (!isInsideOval || !isSizeCorrect) {
              countdown.style.display = 'none';
              isCountingDown = false;
              isDetectionActive = true;
              alignedFrames = 0;
              faceFeedback.innerHTML = !isInsideOval ? 'üòä Centralize o rosto' : (faceWidth < minWidth ? 'üîç Aproxime o rosto' : 'üîç Afaste o rosto');
              if (oval) oval.classList.remove('aligned', 'no-face').add('misaligned');
              console.log('Rosto desalinhado:', { isInsideOval, faceWidth });
              return;
            } else {
              oval.classList.remove('no-face', 'misaligned').add('aligned');
            }
          }

          countdown.style.display = 'none';
          isCountingDown = false;
          isCapturing = true;
          faceFeedback.innerHTML = 'üì∏ Capturando...';
          console.log('Contagem conclu√≠da, capturando');
          captureFace();
        } catch (error) {
          console.error('Erro na contagem:', error);
          showToast('Erro durante a contagem.', 'error', true);
          countdown.style.display = 'none';
          isCountingDown = false;
          isDetectionActive = true;
          faceFeedback.innerHTML = '‚ö†Ô∏è Erro na captura';
          updateDebugStatus('Erro na contagem');
        }
      }

      // Detecta rostos
      async function detectFaces() {
        const now = performance.now();
        if (now - lastDetectionTime < detectionInterval) {
          setTimeout(detectFaces, detectionInterval - (now - lastDetectionTime));
          return;
        }
        lastDetectionTime = now;

        if (!isDetectionActive || faceVideo.paused || faceVideo.ended || isCapturing || isCountingDown) {
          if (!isCountingDown) {
            faceFeedback.innerHTML = '‚è∏Ô∏è Detec√ß√£o pausada';
            faceFeedback.classList.remove('hidden');
          }
          setTimeout(detectFaces, detectionInterval);
          return;
        }

        const dims = getVideoDimensions();
        if (faceVideo.readyState < 2 || !dims.width || !dims.height) {
          faceFeedback.innerHTML = 'üì∑ C√¢mera n√£o est√° pronta';
          showToast('C√¢mera n√£o est√° pronta para detec√ß√£o.', 'error', true);
          updateDebugStatus('Erro: V√≠deo n√£o pronto');
          console.log('Estado do v√≠deo:', { readyState: faceVideo.readyState, width: dims.width, height: dims.height });
          setTimeout(detectFaces, 500);
          return;
        }

        faceFeedback.classList.remove('hidden');

        if (!modelsLoaded) {
          faceFeedback.innerHTML = '‚ö†Ô∏è Carregando detec√ß√£o...';
          setTimeout(detectFaces, 500);
          return;
        }

        try {
          const width = dims.width;
          const height = dims.height;
          tempCanvas.width = width;
          tempCanvas.height = height;
          tempCtx.save();
          tempCtx.scale(-1, 1);
          tempCtx.drawImage(faceVideo, -width, 0, width, height);
          tempCtx.restore();

          const isMobile = window.innerWidth <= 640;
          const options = new faceapi.SsdMobilenetv1Options minConfidence: 0.3});
          let detections = lastDetections;
          if (!detections || now - lastDetectionTime > 100) {
            detections = await faceapi.detectAllFaces(tempCanvas, options).withFaceLandmarks();
            lastDetections = detections;
          }

          const oval = faceOverlay.querySelector('.face-oval');
          if (!oval) {
            setupOverlay();
            faceFeedback.innerHTML = '‚ö†Ô∏è Configurando interface...';
            setTimeout(detectFaces, detectionInterval);
            return;
          }

          updateCachedDimensions();
          const { videoWidth, screenWidth, screenHeight, ovalLeft, ovalRight, ovalTop, ovalBottom, ovalWidth, ovalHeight } = cachedDimensions;
          const scaleX = screenWidth / videoWidth;
          const scaleY = screenHeight / videoHeight;

          if (detections.length === 1) {
            const { box, landmarks } = detections[0];
            const angle = calculateFaceAngle(landmarks);
            if (angle > 15) {
              alignedFrames = 0;
              oval.classList.remove('aligned', 'no-face').add('misaligned');
              faceFeedback.innerHTML = 'üôÇ Alinhe o rosto';
              failedDetections = 0;
              setTimeout(detectFaces, detectionInterval);
              return;
            }

            const faceLeft = screenWidth - (box.x + box.width) * scaleX;
            const faceRight = screenWidth - box.x * scaleX;
            const faceTop = box.y * scaleY;
            const faceBottom = (box.y + box.height) * scaleY;

            const isInsideOval = (
              faceLeft >= ovalLeft + 0.05 * ovalWidth &&
              faceRight <= ovalRight - 0.05 * ovalWidth &&
              faceTop >= ovalTop + 0.05 * ovalHeight &&
              faceBottom <= faceBottom - 0.05 * ovalHeight
            );

            const faceWidth = box.width * scaleX;
            const minWidth = 0.85 * ovalWidth;
            const maxWidth = 1.1 * ovalWidth;
            const isSizeCorrect = faceWidth >= minWidth && faceWidth <= maxWidth;

            console.log('Detec√ß√£o:', { isInsideOval, faceWidth, isSizeCorrect, angle });

            if (isInsideOval && isSizeCorrect) {
              alignedFrames++;
              oval.classList.remove('no-face', 'misaligned').add('aligned');
              if (alignedFrames >= 4) {
                const sharpness = calculateSharpness();
                if (sharpness > 0.05) {
                  faceFeedback.innerHTML = '‚úÖ Encaixe perfeito!';
                  updateDebugStatus('Rosto alinhado');
                  failedDetections = 0;
                  startCountdown();
                  return;
                } else {
                  if (failedDetections < 5) {
                    failedDetections++;
                    faceFeedback.innerHTML = 'üí° V√° para um local mais iluminado';
                    alignedFrames = 0;
                    oval.classList.remove('aligned', 'misaligned').add('no-face');
                  } else {
                    showToast('Ilumina√ß√£o baixa. Capturando manualmente.', 'warning', false);
                    faceFeedback.innerHTML = '‚úÖ Encaixe perfeito!';
                    startCountdown();
                    return;
                  }
                }
              } else {
                faceFeedback.innerHTML = '‚úÖ Encaixe perfeito! Aguarde...';
              }
            } else {
              alignedFrames = 0;
              oval.classList.remove('aligned', 'no-face').add('misaligned');
              faceFeedback.innerHTML = !isInsideOval ? 'üòä Centralize o rosto' : (faceWidth < minWidth ? 'üîç Aproxime o rosto' : 'üîç Afaste o rosto');
            }
          } else {
            alignedFrames = 0;
            oval.classList.remove('aligned', 'misaligned').add('no-face');
            faceFeedback.innerHTML = detections.length === 0 ? 'üò∂ Sem rosto detectado' : '‚ö†Ô∏è Apenas um rosto';
            failedDetections = 0;
          }
        } catch (error) {
          console.error('Erro na detec√ß√£o:', error);
          failedDetections++;
          faceFeedback.innerHTML = '‚ö†Ô∏è Erro na detec√ß√£o';
          updateDebugStatus('Erro na detec√ß√£o: ${error.message}');
          if (failedDetections >= 5) {
            showToast(`Erro persistente: ${error.message}`, 'error', true);
            setTimeout(() => {
              failedDetections = 0;
              detectFaces();
            }, 3000);
            return;
          }
        }
        setTimeout(detectFaces, detectionInterval);
      }

      // Calcula nitidez
      function calculateSharpness() {
        try {
          const regionSize = 80;
          const dims = getVideoDimensions();
          const centerX = dims.width / 2 - regionSize / 2;
          const centerY = dims.height / 2 - regionSize / 2;
          const imageData = tempCtx.getImageData(centerX, centerY, regionSize, regionSize);
          const data = imageData.data;
          let laplacianSum = 0;
          let count = 0;

          for (let i = 1; i < regionSize - 1; i++) {
            for (let j = 1; j < regionSize - 1; j++) {
              const idx = (i * regionSize + j) * 4;
              const gray = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
              const laplacian =
                -4 * gray +
                (data[((i - 1) * regionSize + j) * 4] * 0.299 + data[((i - 1) * regionSize + j) * 4 + 1] * 0.587 + data[((i - 1) * regionSize + j) * 4 + 2] * 0.114) +
                (data[((i + 1) * regionSize + j) * 4] * 0.299 + data[((i + 1) * regionSize + j) * 4 + 1] * 0.587 + data[((i + 1) * regionSize + j) * 4 + 2] * 0.114) +
                (data[(i * regionSize + (j - 1)) * 4] * 0.299 + data[(i * regionSize + (j - 1)) * 4 + 1] * 0.587 + data[(i * regionSize + (j - 1)) * 4 + 2] * 0.114) +
                (data[(i * regionSize + (j + 1)) * 4] * 0.299 + data[(i * regionSize + (j + 1)) * 4 + 1] * 0.587 + data[(i * regionSize + (j + 1)) * 4 + 2] * 0.114);
              laplacianSum += laplacian * laplacian;
              count++;
            }
          }
          const sharpness = count ? laplacianSum / count : 0;
          return sharpness / 1000;
        } catch (error) {
          console.error('Erro ao calcular nitidez:', error);
          showToast('Erro na an√°lise de imagem.', 'error', true);
          return 0;
        }
      }

      // Captura a foto
      function captureFace() {
        const dims = getVideoDimensions();
        if (faceVideo.readyState < 2 || !dims.width || !dims.height) {
          showToast('C√¢mera n√£o est√° pronta.', 'error', true);
          isCapturing = false;
          isDetectionActive = true;
          detectFaces();
          return;
        }

        try {
          faceCanvas.width = dims.width;
          faceCanvas.height = dims.height;
          const ctx = faceCanvas.getContext('2d');
          ctx.save();
          ctx.scale(-1, 1);
          ctx.drawImage(faceVideo, -dims.width, 0, dims.width, dims.height);
          ctx.restore();

          const targetWidth = Math.min(dims.width, dims.height * 3 / 4);
          const targetHeight = targetWidth * 4 / 3;
          const offsetX = (dims.width - targetWidth) / 2;
          const offsetY = (dims.height - targetHeight) / 2;

          const cropCanvas = document.createElement('canvas');
          cropCanvas.width = targetWidth;
          cropCanvas.height = targetHeight;
          const cropCtx = cropCanvas.getContext('2d');
          cropCtx.drawImage(
            faceCanvas,
            offsetX, offsetY, targetWidth, targetHeight,
            0, 0, targetWidth, targetHeight
          );

          const imageData = cropCanvas.toDataURL('image/jpeg', 0.8);
          if (!imageData || imageData === 'data:,') {
            throw new Error('Imagem inv√°lida');
          }
          confirmationImage.src = imageData;
          confirmationModal.classList.remove('hidden');
          updateDebugStatus('Foto capturada');
        } catch (error) {
          console.error('Erro ao capturar:', error);
          showToast('Erro ao capturar foto.', 'error', true);
          isCapturing = false;
          isDetectionActive = true;
          detectFaces();
        }

        stopStream();
        faceFeedback.classList.add('hidden');
        faceOverlay.innerHTML = '';
      }

      // Event listeners
      startButton.addEventListener('click', () => {
        startButton.style.display = 'none';
        initialize();
      });

      repeatButton.addEventListener('click', () => {
        confirmationModal.classList.add('hidden');
        confirmationImage.src = '';
        isCapturing = false;
        alignedFrames = 0;
        isDetectionActive = true;
        isCountingDown = false;
        failedDetections = 0;
        countdown.style.display = 'none';
        stopStream();
        faceFeedback.classList.remove('hidden');
        faceFeedback.innerHTML = 'üòä Centralize o rosto';
        updateDebugStatus('Reiniciando captura');
        initialize();
      });

      sendButton.addEventListener('click', () => {
        sessionStorage.setItem('facePhoto', confirmationImage.src);
        confirmationModal.classList.add('hidden');
        updateDebugStatus('Imagem enviada');
        const urlParams = new URLSearchParams(window.location.search);
        const returnPage = urlParams.get('return') || 'index.html';
        window.location.href = returnPage;
      });

      confirmationImage.addEventListener('click', () => {
        confirmationImage.classList.toggle('zoomed');
      });

      fallbackButton.addEventListener('click', () => {
        fallbackButton.style.display = 'none';
        initialize();
      });

      // Inicializa automaticamente
      async function initialize() {
        modelLoading.classList.remove('hidden');
        updateDebugStatus('Inicializando...');
        try {
          if (!modelsLoaded) {
            await loadModels();
          }
          const videoStarted = await startVideo();
          if (!videoStarted) {
            throw new Error('Falha ao iniciar o v√≠deo');
          }
          faceFeedback.innerHTML = 'üòä Centralize o rosto';
        } catch (error) {
          console.error('Erro na inicializa√ß√£o:', error);
          showToast(`Erro ao iniciar: ${error.message}`, 'error', true);
          startButton.style.display = 'block';
          updateDebugStatus('Erro na inicializa√ß√£o');
        } finally {
          modelLoading.classList.add('hidden');
        }
      }

      // Inicia automaticamente
      initialize();
    });
  </script>
</body>
</html>
