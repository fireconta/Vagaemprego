<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Captura de Rosto</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      background: linear-gradient(to bottom, #0f172a, #1e3a8a);
      font-family: 'Inter', sans-serif;
      min-height: 100vh;
      margin: 0;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .capture-container {
      position: relative;
      z-index: 1000;
      background: transparent;
      width: 100vw;
      height: 100vh;
      text-align: center;
    }
    .fullscreen-video {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: 1000;
      transform: scaleX(-1);
      display: block;
    }
    .confirmation-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(12px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1003;
      padding: 20px;
    }
    .confirmation-modal img {
      max-width: 85%;
      max-height: 60%;
      aspect-ratio: 3 / 4;
      object-fit: cover;
      border-radius: 16px;
      border: 3px solid #ffffff;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
      cursor: zoom-in;
      transition: transform 0.3s ease;
    }
    .confirmation-modal img:focus,
    .confirmation-modal img.zoomed {
      transform: scale(1.3);
    }
    .confirmation-modal .buttons {
      display: flex;
      justify-content: center;
      gap: 1.5rem;
      width: 100%;
      max-width: 600px;
      margin-top: 20px;
    }
    .modal-button {
      background: #3b82f6;
      border-radius: 10px;
      padding: 14px 0;
      font-size: 16px;
      font-weight: 600;
      color: white;
      border: none;
      cursor: pointer;
      transition: background 0.2s, transform 0.2s;
      width: 45%;
      max-width: 200px;
    }
    .modal-button:hover {
      background: #2563eb;
      transform: translateY(-2px);
    }
    .modal-button.send {
      background: #10b981;
    }
    .modal-button.send:hover {
      background: #059669;
    }
    .face-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1001;
      pointer-events: none;
    }
    .face-oval {
      border: 6px solid #ffffff;
      border-radius: 50%;
      width: 350px;
      height: 525px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
      background: transparent;
      display: block;
    }
    .face-oval.aligned {
      border-color: #10b981;
      animation: pulse 1s infinite ease-in-out;
    }
    @keyframes pulse {
      0% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 15px rgba(16, 185, 129, 0.3); }
      50% { transform: translate(-50%, -50%) scale(1.015); box-shadow: 0 0 25px rgba(16, 185, 129, 0.5); }
      100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 15px rgba(16, 185, 129, 0.3); }
    }
    .face-feedback {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.75);
      color: white;
      padding: 14px 28px;
      border-radius: 10px;
      font-size: 18px;
      font-weight: 600;
      z-index: 1002;
      max-width: 90%;
      text-align: center;
      animation: fadeIn 0.4s ease-in-out;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }
    .countdown {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      color: white;
      font-size: 80px;
      font-weight: 700;
      padding: 20px 40px;
      border-radius: 15px;
      z-index: 1003;
      display: none;
      animation: countdownFade 1s ease-in-out;
    }
    @keyframes countdownFade {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
      50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
      100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(-50%) translateY(15px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      font-size: 14px;
      z-index: 1006;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: center;
      gap: 8px;
      max-width: 90%;
    }
    .toast-error { background: #ef4444; }
    .toast-success { background: #10b981; }
    .toast-warning { background: #f59e0b; }
    .retry-button {
      background: #3b82f6;
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: background 0.2s;
    }
    .retry-button:hover {
      background: #2563eb;
    }
    .model-loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      z-index: 1004;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .model-loading::after {
      content: '';
      width: 14px;
      height: 14px;
      border: 2px solid white;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .debug-status {
      position: fixed;
      top: 8px;
      left: 8px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 11px;
      z-index: 1007;
    }
    .fallback-button {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #3b82f6;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      z-index: 1003;
      display: none;
    }
    .fallback-button:hover {
      background: #2563eb;
    }
    @media (max-width: 640px) {
      .face-feedback {
        bottom: 80px;
        font-size: 16px;
        padding: 12px 20px;
      }
      .confirmation-modal img {
        max-width: 90%;
        max-height: 50%;
      }
      .confirmation-modal .buttons {
        flex-direction: column;
        gap: 1rem;
        margin-top: 16px;
      }
      .modal-button {
        width: 80%;
        padding: 12px 0;
        font-size: 15px;
      }
      .face-oval {
        width: 300px;
        height: 450px;
      }
      .countdown {
        font-size: 60px;
        padding: 15px 30px;
      }
      .toast {
        font-size: 13px;
        padding: 10px 20px;
        max-width: 85%;
      }
    }
  </style>
</head>
<body role="application" aria-label="Aplicação de captura de rosto">
  <div class="capture-container">
    <video id="face-video" autoplay playsinline muted aria-hidden="true"></video>
    <canvas id="face-canvas" class="hidden" aria-hidden="true"></canvas>
    <div id="face-overlay" class="face-overlay"></div>
    <div id="face-feedback" class="face-feedback">Encaixe o rosto no oval</div>
    <div id="countdown" class="countdown" aria-live="polite"></div>
    <div id="confirmationModal" class="confirmation-modal hidden">
      <img id="confirmationImage" src="" alt="Foto capturada para verificação" tabindex="0">
      <div class="buttons">
        <button id="repeatButton" class="modal-button" aria-label="Repetir captura">Repetir</button>
        <button id="sendButton" class="modal-button send" aria-label="Enviar foto">Enviar</button>
      </div>
    </div>
    <div id="toast" class="toast hidden" aria-live="polite"></div>
    <button id="fallbackButton" class="fallback-button">Tentar Novamente</button>
  </div>
  <div id="modelLoading" class="model-loading hidden" aria-live="polite">Carregando...</div>
  <div id="debugStatus" class="debug-status">Inicializando...</div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
        showToast('Este aplicativo requer HTTPS. Use um servidor seguro.', 'error', false);
        updateDebugStatus('Erro: HTTPS necessário');
        return;
      }

      // Elementos DOM
      const faceVideo = document.getElementById('face-video');
      const faceCanvas = document.getElementById('face-canvas');
      const faceOverlay = document.getElementById('face-overlay');
      const faceFeedback = document.getElementById('face-feedback');
      const countdown = document.getElementById('countdown');
      const confirmationModal = document.getElementById('confirmationModal');
      const confirmationImage = document.getElementById('confirmationImage');
      const repeatButton = document.getElementById('repeatButton');
      const sendButton = document.getElementById('sendButton');
      const toast = document.getElementById('toast');
      const modelLoading = document.getElementById('modelLoading');
      const debugStatus = document.getElementById('debugStatus');
      const fallbackButton = document.getElementById('fallbackButton');

      // Variáveis de estado
      let stream = null;
      let isCapturing = false;
      let alignedFrames = 0;
      let isDetectionActive = false;
      let modelsLoaded = false;
      let isCountingDown = false;
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');

      // Inicialização
      confirmationModal.classList.add('hidden');
      confirmationImage.src = '';
      sessionStorage.removeItem('facePhoto');

      // Funções auxiliares
      function updateDebugStatus(message) {
        debugStatus.textContent = message;
        console.log(`Status: ${message}`);
      }

      function showToast(message, type = 'error', showRetry = true) {
        toast.innerHTML = message + (showRetry ? ' <button class="retry-button">Tentar novamente</button>' : '');
        toast.className = `toast toast-${type}`;
        toast.classList.remove('hidden');
        setTimeout(() => toast.classList.add('hidden'), type === 'error' ? 10000 : 4000);
        if (showRetry) {
          const retryButton = toast.querySelector('.retry-button');
          retryButton.removeEventListener('click', initialize);
          retryButton.addEventListener('click', initialize, { once: true });
        }
      }

      function stopStream() {
        if (stream) {
          stream.getTracks().forEach(track => track.stop());
          stream = null;
          faceVideo.srcObject = null;
          faceVideo.pause();
          console.log('Stream fechado');
          updateDebugStatus('Stream fechado');
        }
      }

      // Carrega modelos de detecção facial
      async function loadModels(attempt = 1, maxAttempts = 3) {
        const path = 'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights/';
        try {
          console.log(`Tentativa ${attempt} de carregar modelos`);
          updateDebugStatus(`Carregando modelos (${attempt}/${maxAttempts})`);
          await Promise.race([
            Promise.all([
              faceapi.nets.tinyFaceDetector.loadFromUri(path),
              faceapi.nets.faceLandmark68Net.loadFromUri(path)
            ]),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout nos modelos')), 10000))
          ]);
          modelsLoaded = true;
          console.log('Modelos carregados');
          showToast('Pronto para capturar!', 'success', false);
          updateDebugStatus('Modelos carregados');
          return true;
        } catch (error) {
          console.error(`Erro ao carregar modelos (tentativa ${attempt}):`, error);
          updateDebugStatus(`Erro nos modelos (${attempt}/${maxAttempts})`);
          if (attempt < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            return loadModels(attempt + 1, maxAttempts);
          }
          showToast('Erro ao carregar detecção facial.', 'warning', true);
          updateDebugStatus('Falha nos modelos');
          return false;
        }
      }

      // Configura o overlay com oval
      function setupOverlay() {
        console.log('Configurando oval...');
        faceOverlay.innerHTML = '';
        const oval = document.createElement('div');
        oval.classList.add('face-oval');
        faceOverlay.appendChild(oval);
        const ovalRect = oval.getBoundingClientRect();
        console.log('Oval criado:', {
          width: ovalRect.width,
          height: ovalRect.height,
          top: ovalRect.top,
          left: ovalRect.left
        });
        updateDebugStatus('Oval configurado');
        oval.style.display = 'block';
        oval.style.border = '6px solid #ffffff';
      }

      // Verifica permissões da câmera
      async function checkCameraPermission() {
        try {
          const permissionStatus = await navigator.permissions.query({ name: 'camera' });
          console.log('Permissão da câmera:', permissionStatus.state);
          if (permissionStatus.state === 'denied') {
            return { granted: false, message: 'Permissão para câmera negada. Habilite nas configurações do navegador.' };
          }
          return { granted: permissionStatus.state === 'granted' };
        } catch (error) {
          console.error('Erro ao verificar permissão:', error);
          return { granted: false, message: 'Erro ao verificar permissão da câmera.' };
        }
      }

      // Inicia o vídeo da câmera
      async function startVideo(attempt = 1, maxAttempts = 3) {
        try {
          updateDebugStatus('Iniciando vídeo...');
          console.log(`Tentativa ${attempt} de iniciar vídeo`);
          stopStream();
          faceVideo.classList.add('fullscreen-video');
          faceVideo.style.display = 'block';

          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('API de mídia não suportada pelo navegador.');
          }

          const permission = await checkCameraPermission();
          if (!permission.granted) {
            throw new Error(permission.message || 'Permissão da câmera não concedida.');
          }

          const constraints = {
            video: {
              facingMode: 'user',
              width: { ideal: 1280 },
              height: { ideal: 720 },
              frameRate: { ideal: 30 }
            }
          };

          stream = await navigator.mediaDevices.getUserMedia(constraints);
          if (!stream.active) throw new Error('Stream inválido');
          faceVideo.srcObject = stream;
          console.log('Stream iniciado');
          updateDebugStatus('Stream ativo');

          await new Promise((resolve, reject) => {
            faceVideo.onloadedmetadata = () => {
              console.log('Metadados do vídeo:', {
                width: faceVideo.videoWidth,
                height: faceVideo.videoHeight
              });
              tempCanvas.width = faceVideo.videoWidth;
              tempCanvas.height = faceVideo.videoHeight;
              faceCanvas.width = faceVideo.videoWidth;
              faceCanvas.height = faceVideo.videoHeight;
              updateDebugStatus('Resolução definida');
              resolve();
            };
            faceVideo.onerror = () => {
              console.error('Erro no vídeo');
              updateDebugStatus('Erro no stream');
              reject(new Error('Erro no stream'));
            };
          });

          await faceVideo.play();
          console.log('Vídeo iniciado');
          updateDebugStatus('Vídeo iniciado');
          fallbackButton.classList.add('hidden');
          setupOverlay();
          isDetectionActive = true;
          detectFaces();
        } catch (error) {
          console.error(`Erro ao iniciar vídeo (tentativa ${attempt}):`, error);
          let errorMessage = 'Não foi possível acessar a câmera.';
          if (error.name === 'NotAllowedError' || error.message.includes('Permissão')) {
            errorMessage = 'Permissão para câmera negada. Habilite nas configurações do navegador.';
          } else if (error.name === 'NotFoundError') {
            errorMessage = 'Nenhuma câmera encontrada. Verifique o dispositivo.';
          } else if (error.name === 'NotReadableError') {
            errorMessage = 'Câmera em uso por outro aplicativo. Feche outros apps.';
          } else if (error.name === 'OverconstrainedError') {
            errorMessage = 'Resolução não suportada. Tente outro dispositivo.';
          }
          updateDebugStatus(`Erro no vídeo: ${errorMessage}`);
          showToast(errorMessage, 'error', true);
          if (attempt < maxAttempts && error.name === 'NotReadableError') {
            console.log(`Tentando novamente em 1s (tentativa ${attempt + 1})`);
            await new Promise(resolve => setTimeout(resolve, 1000));
            return startVideo(attempt + 1, maxAttempts);
          }
          fallbackButton.classList.remove('hidden');
          stopStream();
        }
      }

      // Inicia a contagem regressiva
      async function startCountdown() {
        if (isCountingDown || isCapturing) return;
        isCountingDown = true;
        isDetectionActive = false;
        faceFeedback.innerHTML = 'Mantenha o rosto no centro';
        countdown.style.display = 'block';
        console.log('Iniciando contagem regressiva');

        for (let i = 3; i >= 1; i--) {
          countdown.textContent = i;
          await new Promise(resolve => setTimeout(resolve, 1000));

          // Verifica se o rosto ainda está alinhado
          tempCtx.save();
          tempCtx.scale(-1, 1);
          tempCtx.drawImage(faceVideo, -faceVideo.videoWidth, 0, faceVideo.videoWidth, faceVideo.videoHeight);
          tempCtx.restore();

          const options = new faceapi.TinyFaceDetectorOptions({ inputSize: 320, scoreThreshold: 0.4 });
          const detections = await faceapi.detectAllFaces(tempCanvas, options).withFaceLandmarks();
          const oval = faceOverlay.querySelector('.face-oval');
          if (!oval || detections.length !== 1) {
            countdown.style.display = 'none';
            isCountingDown = false;
            isDetectionActive = true;
            faceFeedback.innerHTML = detections.length === 0 ? '😶 Nenhum rosto detectado' : '⚠️ Apenas um rosto';
            alignedFrames = 0;
            console.log('Contagem interrompida: rosto inválido');
            return;
          }

          const { box } = detections[0].detection;
          const videoWidth = faceVideo.videoWidth;
          const videoHeight = faceVideo.videoHeight;
          const screenWidth = window.innerWidth;
          const screenHeight = window.innerHeight;
          const scaleX = screenWidth / videoWidth;
          const scaleY = screenHeight / videoHeight;
          const ovalRect = oval.getBoundingClientRect();

          const ovalLeft = ovalRect.left;
          const ovalRight = ovalRect.right;
          const ovalTop = ovalRect.top;
          const ovalBottom = ovalRect.bottom;
          const ovalWidth = ovalRect.width;
          const ovalHeight = ovalRect.height;

          const faceLeft = screenWidth - (box.x + box.width) * scaleX;
          const faceRight = screenWidth - box.x * scaleX;
          const faceTop = box.y * scaleY;
          const faceBottom = (box.y + box.height) * scaleY;

          const isInsideOval = (
            faceLeft >= ovalLeft + 0.01 * ovalWidth &&
            faceRight <= ovalRight - 0.01 * ovalWidth &&
            faceTop >= ovalTop + 0.01 * ovalHeight &&
            faceBottom <= ovalBottom - 0.01 * ovalHeight
          );

          const faceWidth = box.width * scaleX;
          const minWidth = 0.75 * ovalWidth;
          const maxWidth = 1.1 * ovalWidth;
          const isSizeCorrect = faceWidth >= minWidth && faceWidth <= maxWidth;

          if (!isInsideOval || !isSizeCorrect) {
            countdown.style.display = 'none';
            isCountingDown = false;
            isDetectionActive = true;
            faceFeedback.innerHTML = !isInsideOval ? '↔️ Encaixe o rosto no centro' : (faceWidth < minWidth ? '🔍 Aproxime o rosto' : '🔍 Afaste o rosto');
            alignedFrames = 0;
            console.log('Contagem interrompida: rosto desalinhado');
            return;
          }
        }

        countdown.style.display = 'none';
        isCountingDown = false;
        isCapturing = true;
        faceFeedback.innerHTML = '📸 Capturando agora...';
        updateDebugStatus('Capturando');
        console.log('Contagem concluída, capturando');
        captureFace();
      }

      // Detecta rostos e verifica alinhamento
      async function detectFaces() {
        if (!isDetectionActive || faceVideo.paused || faceVideo.ended || isCapturing || isCountingDown) {
          console.log('Detecção pausada:', { isDetectionActive, isCapturing, isCountingDown, paused: faceVideo.paused, ended: faceVideo.ended });
          if (!isCountingDown) faceFeedback.innerHTML = '⏸️ Detecção pausada';
          faceFeedback.classList.remove('hidden');
          setTimeout(detectFaces, 100);
          return;
        }

        faceFeedback.classList.remove('hidden');
        if (!modelsLoaded) {
          faceFeedback.innerHTML = '⚠️ Carregando detecção...';
          requestAnimationFrame(detectFaces);
          return;
        }

        try {
          tempCtx.save();
          tempCtx.scale(-1, 1);
          tempCtx.drawImage(faceVideo, -faceVideo.videoWidth, 0, faceVideo.videoWidth, faceVideo.videoHeight);
          tempCtx.restore();

          const options = new faceapi.TinyFaceDetectorOptions({ inputSize: 320, scoreThreshold: 0.4 });
          const detections = await faceapi.detectAllFaces(tempCanvas, options).withFaceLandmarks();

          const oval = faceOverlay.querySelector('.face-oval');
          if (!oval) {
            console.error('Oval não encontrado');
            setupOverlay();
            faceFeedback.innerHTML = '⚠️ Configurando interface...';
            requestAnimationFrame(detectFaces);
            return;
          }

          const videoWidth = faceVideo.videoWidth;
          const videoHeight = faceVideo.videoHeight;
          const screenWidth = window.innerWidth;
          const screenHeight = window.innerHeight;
          const scaleX = screenWidth / videoWidth;
          const scaleY = screenHeight / videoHeight;
          const ovalRect = oval.getBoundingClientRect();

          const ovalLeft = ovalRect.left;
          const ovalRight = ovalRect.right;
          const ovalTop = ovalRect.top;
          const ovalBottom = ovalRect.bottom;
          const ovalWidth = ovalRect.width;
          const ovalHeight = ovalRect.height;

          if (detections.length === 1) {
            const { box } = detections[0].detection;
            const faceLeft = screenWidth - (box.x + box.width) * scaleX;
            const faceRight = screenWidth - box.x * scaleX;
            const faceTop = box.y * scaleY;
            const faceBottom = (box.y + box.height) * scaleY;

            const isInsideOval = (
              faceLeft >= ovalLeft + 0.01 * ovalWidth &&
              faceRight <= ovalRight - 0.01 * ovalWidth &&
              faceTop >= ovalTop + 0.01 * ovalHeight &&
              faceBottom <= ovalBottom - 0.01 * ovalHeight
            );

            const faceWidth = box.width * scaleX;
            const minWidth = 0.75 * ovalWidth;
            const maxWidth = 1.1 * ovalWidth;
            const isSizeCorrect = faceWidth >= minWidth && faceWidth <= maxWidth;

            console.log('Detecção:', {
              face: { left: faceLeft, right: faceRight, top: faceTop, bottom: faceBottom },
              oval: { left: ovalLeft, right: ovalRight, top: ovalTop, bottom: ovalBottom },
              isInsideOval,
              faceWidth,
              minWidth,
              maxWidth,
              isSizeCorrect
            });

            if (isInsideOval && isSizeCorrect) {
              alignedFrames++;
              console.log(`Frame alinhado ${alignedFrames}/2`);
              if (alignedFrames >= 2) {
                oval.classList.add('aligned');
                const sharpness = calculateSharpness();
                console.log('Nitidez:', sharpness);
                if (sharpness > 0.03) {
                  faceFeedback.innerHTML = '✅ Encaixe perfeito! Preparando...';
                  updateDebugStatus('Rosto alinhado, iniciando contagem');
                  startCountdown();
                  return;
                } else {
                  faceFeedback.innerHTML = '💡 Melhore a iluminação';
                  alignedFrames = 0;
                  console.log('Nitidez insuficiente');
                }
              } else {
                faceFeedback.innerHTML = '✅ Encaixe perfeito! Aguarde...';
                updateDebugStatus('Rosto alinhado');
              }
            } else {
              alignedFrames = 0;
              oval.classList.remove('aligned');
              if (!isInsideOval) {
                faceFeedback.innerHTML = '↔ Encaixe o rosto no oval';
              } else if (faceWidth < minWidth) {
                faceFeedback.innerHTML = '🔍 Aproxime o rosto';
              } else {
                faceFeedback.innerHTML = '🔍 Afaste o rosto';
              }
              updateDebugStatus('Rosto desalinhado');
            }
          } else {
            alignedFrames = 0;
            oval.classList.remove('aligned');
            faceFeedback.innerHTML = detections.length === 0 ? '😶 Nenhum rosto detectado' : '⚠️ Apenas um rosto';
            updateDebugStatus('Nenhum ou múltiplos rostos');
          }
        } catch (error) {
          console.error('Erro na detecção:', error);
          showToast('Erro na detecção facial.', 'error', true);
          updateDebugStatus('Erro na detecção');
          faceFeedback.innerHTML = '⚠️ Erro na detecção';
        }
        requestAnimationFrame(detectFaces);
      }

      // Calcula nitidez da imagem
      function calculateSharpness() {
        try {
          const regionSize = 80;
          const centerX = faceVideo.videoWidth / 2 - regionSize / 2;
          const centerY = faceVideo.videoHeight / 2 - regionSize / 2;
          const imageData = tempCtx.getImageData(centerX, centerY, regionSize, regionSize);
          const data = imageData.data;
          let laplacianSum = 0;
          let count = 0;

          for (let i = 1; i < regionSize - 1; i++) {
            for (let j = 1; j < regionSize - 1; j++) {
              const idx = (i * regionSize + j) * 4;
              const gray = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
              const laplacian =
                -4 * gray +
                (data[((i - 1) * regionSize + j) * 4] * 0.299 + data[((i - 1) * regionSize + j) * 4 + 1] * 0.587 + data[((i - 1) * regionSize + j) * 4 + 2] * 0.114) +
                (data[((i + 1) * regionSize + j) * 4] * 0.299 + data[((i + 1) * regionSize + j) * 4 + 1] * 0.587 + data[((i + 1) * regionSize + j) * 4 + 2] * 0.114) +
                (data[(i * regionSize + (j - 1)) * 4] * 0.299 + data[(i * regionSize + (j - 1)) * 4 + 1] * 0.587 + data[(i * regionSize + (j - 1)) * 4 + 2] * 0.114) +
                (data[(i * regionSize + (j + 1)) * 4] * 0.299 + data[(i * regionSize + (j + 1)) * 4 + 1] * 0.587 + data[(i * regionSize + (j + 1)) * 4 + 2] * 0.114);
              laplacianSum += laplacian * laplacian;
              count++;
            }
          }
          const sharpness = count ? laplacianSum / count : 0;
          const normalizedSharpness = sharpness / 1000;
          return normalizedSharpness;
        } catch (error) {
          console.error('Erro ao calcular nitidez:', error);
          showToast('Erro na análise de imagem.', 'error', true);
          updateDebugStatus('Erro na nitidez');
          return 0;
        }
      }

      // Captura a foto
      function captureFace() {
        if (faceVideo.readyState < 2) {
          showToast('Câmera não está pronta.', 'error', true);
          isCapturing = false;
          isDetectionActive = true;
          detectFaces();
          updateDebugStatus('Vídeo não capturável');
          return;
        }

        faceCanvas.width = faceVideo.videoWidth;
        faceCanvas.height = faceVideo.videoHeight;
        const ctx = faceCanvas.getContext('2d');
        ctx.save();
        ctx.scale(-1, 1);
        ctx.drawImage(faceVideo, -faceVideo.videoWidth, 0, faceVideo.videoWidth, faceVideo.videoHeight);
        ctx.restore();

        try {
          const targetWidth = Math.min(faceVideo.videoWidth, faceVideo.videoHeight * 3 / 4);
          const targetHeight = targetWidth * 4 / 3;
          const offsetX = (faceVideo.videoWidth - targetWidth) / 2;
          const offsetY = (faceVideo.videoHeight - targetHeight) / 2;

          const cropCanvas = document.createElement('canvas');
          cropCanvas.width = targetWidth;
          cropCanvas.height = targetHeight;
          const cropCtx = cropCanvas.getContext('2d');
          cropCtx.drawImage(
            faceCanvas,
            offsetX, offsetY, targetWidth, targetHeight,
            0, 0, targetWidth, targetHeight
          );

          const imageData = cropCanvas.toDataURL('image/jpeg', 0.98);
          if (!imageData || imageData === 'data:,') {
            throw new Error('Imagem inválida');
          }
          confirmationImage.src = imageData;
          confirmationModal.classList.remove('hidden');
          console.log('Foto capturada');
          updateDebugStatus('Foto capturada');
        } catch (error) {
          console.error('Erro ao capturar:', error);
          showToast('Erro ao capturar foto.', 'error', true);
          isCapturing = false;
          isDetectionActive = true;
          detectFaces();
          updateDebugStatus('Erro na captura');
          return;
        }

        stopStream();
        faceFeedback.classList.add('hidden');
        faceOverlay.innerHTML = '';
      }

      // Event listeners
      repeatButton.addEventListener('click', () => {
        console.log('Botão Repetir clicado');
        confirmationModal.classList.add('hidden');
        confirmationImage.src = '';
        isCapturing = false;
        alignedFrames = 0;
        isDetectionActive = true;
        isCountingDown = false;
        countdown.style.display = 'none';
        stopStream();
        faceFeedback.classList.remove('hidden');
        faceFeedback.innerHTML = 'Encaixe o rosto no oval';
        updateDebugStatus('Reiniciando captura');
        initialize();
      });

      sendButton.addEventListener('click', () => {
        sessionStorage.setItem('facePhoto', confirmationImage.src);
        confirmationModal.classList.add('hidden');
        console.log('Foto enviada');
        updateDebugStatus('Foto enviada');
        const urlParams = new URLSearchParams(window.location.search);
        const returnPage = urlParams.get('return') || 'index.html';
        window.location.href = returnPage;
      });

      confirmationImage.addEventListener('click', () => {
        confirmationImage.classList.toggle('zoomed');
        console.log('Zoom da imagem');
        updateDebugStatus('Zoom');
      });

      fallbackButton.addEventListener('click', () => {
        fallbackButton.classList.add('hidden');
        initialize();
        console.log('Fallback clicado');
        updateDebugStatus('Fallback acionado');
      });

      document.addEventListener('click', () => {
        if (faceVideo.paused && stream) {
          faceVideo.play().catch(err => {
            console.error('Erro ao play:', err);
            updateDebugStatus('Erro ao play');
            fallbackButton.classList.remove('hidden');
          });
        }
      }, { once: true });

      // Inicializa a aplicação
      async function initialize() {
        modelLoading.classList.remove('hidden');
        updateDebugStatus('Inicializando...');
        try {
          await startVideo();
          if (!modelsLoaded) {
            await loadModels();
          }
          faceFeedback.innerHTML = 'Encaixe o rosto no oval';
          faceFeedback.classList.remove('hidden');
        } catch (error) {
          console.error('Erro na inicialização:', error);
          showToast('Erro ao iniciar. Tente novamente.', 'error', true);
          updateDebugStatus('Erro na inicialização');
          fallbackButton.classList.remove('hidden');
        } finally {
          modelLoading.classList.add('hidden');
        }
      }

      initialize();
    });
  </script>
</body>
</html>
